// Generated by CoffeeScript 1.7.1
(function() {
  var FolderWatcher, TailWatcher, async, events, fs,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  events = require('events');

  async = require('async');

  fs = require('fs');

  TailWatcher = (function(_super) {
    __extends(TailWatcher, _super);

    function TailWatcher(filepath) {
      this.filepath = filepath;
      this.readLine = __bind(this.readLine, this);
      this.buffer = '';
      this.dispatcher = new events.EventEmitter();
      this.queue = [];
      this.watching_p = false;
      this.pos = fs.statSync(this.filepath).size;
      this.dispatcher.on('push', this.readLine);
      this.watch();
    }

    TailWatcher.prototype.watch = function() {
      var error;
      if (this.watching_p) {
        return;
      }
      if (fs.watch) {
        try {
          return this.watcher = fs.watch(this.filepath, (function(_this) {
            return function(event) {
              return _this.handleWatchEvent(event);
            };
          })(this));
        } catch (_error) {
          error = _error;
          return console.log("error caused! can not read " + this.filepath);
        }
      } else {
        try {
          return fs.wathcFile(this.filepath, (function(_this) {
            return function(cur, pre) {
              return _this.handleWatchFileEvent(cur, pre);
            };
          })(this));
        } catch (_error) {
          error = _error;
          return console.log("error caused! can not read " + this.filepath);
        }
      }
    };

    TailWatcher.prototype.handleWatchEvent = function(event) {
      if (event === 'change') {
        return fs.stat(this.filepath, (function(_this) {
          return function(err, stats) {
            if (err) {
              console.log("error: " + err);
              return _this.emit('error', err);
            } else {
              if (stats.size < _this.pos) {
                _this.pos = stats.size;
              }
              if (stats.size > _this.pos) {
                _this.queue.push({
                  start: _this.pos,
                  end: stats.size
                });
                _this.pos = stats.size;
                if (_this.queue.length === 1) {
                  return _this.dispatcher.emit('push');
                }
              }
            }
          };
        })(this));
      } else if (event === 'rename') {
        this.unwatch();
        return setTimeout(((function(_this) {
          return function() {
            return _this.watch();
          };
        })(this)), 1000);
      }
    };

    TailWatcher.prototype.handleWatchFileEvent = function(cur, pre) {
      if (cur.size > pre.size) {
        this.queue.push({
          start: pre.size,
          end: cur.size
        });
        if (this.queue.length === 1) {
          return this.dispatcher.emit('push');
        }
      }
    };

    TailWatcher.prototype.unwatch = function() {
      if (fs.watch && this.watcher) {
        this.watcher.close();
        this.pos = 0;
      } else {
        fs.unwatchFile(this.filepath);
      }
      this.watching_p = false;
      return this.queue = [];
    };

    TailWatcher.prototype.readLine = function() {
      var line, stream;
      if (this.queue.length >= 1) {
        line = this.queue.shift();
        if (line.end > line.start) {
          stream = fs.createReadStream(this.filepath, {
            start: line.start,
            end: line.end - 1,
            encoding: "utf-8"
          });
          stream.on('error', (function(_this) {
            return function(err) {
              console.log("error: " + err);
              return _this.emit('error', err);
            };
          })(this));
          stream.on('end', (function(_this) {
            return function() {
              if (_this.queue.length >= 1) {
                return _this.dispatcher.emit('push');
              }
            };
          })(this));
          return stream.on('data', (function(_this) {
            return function(data) {
              var chunk, lines, _i, _len, _results;
              _this.buffer += data;
              lines = _this.buffer.trim().split('\n');
              _this.buffer = '';
              _results = [];
              for (_i = 0, _len = lines.length; _i < _len; _i++) {
                chunk = lines[_i];
                _results.push(_this.emit('push', {
                  file: _this.filepath,
                  data: chunk
                }));
              }
              return _results;
            };
          })(this));
        }
      }
    };

    return TailWatcher;

  })(events.EventEmitter);

  FolderWatcher = (function(_super) {
    __extends(FolderWatcher, _super);

    function FolderWatcher(folderpath) {
      this.folderpath = folderpath;
      if (this.folderpath[this.folderpath.length - 1] !== '/') {
        this.folderpath += '/';
      }
      this.files = fs.readdirSync(this.folderpath);
      async.forEach(this.files, (function(_this) {
        return function(file) {
          return (new TailWatcher(_this.folderpath + file)).on('push', function(data) {
            return _this.emit('push', data);
          });
        };
      })(this));
      this.watchFolder();
    }

    FolderWatcher.prototype.watchFolder = function() {
      if (fs.watch) {
        return fs.watch(this.folderpath, (function(_this) {
          return function(event) {
            return _this.handleEvent();
          };
        })(this));
      } else {
        return fs.wathcFile(this.folderpath, (function(_this) {
          return function(cur, pre) {
            return _this.handleEvent();
          };
        })(this));
      }
    };

    FolderWatcher.prototype.handleEvent = function() {
      var file, files, _i, _len, _results;
      files = fs.readdirSync(this.folderpath);
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (this.files.indexOf(file) === -1) {
          this.files.push(file);
          _results.push((new TailWatcher(this.folderpath + file)).on('push', (function(_this) {
            return function(data) {
              return _this.emit('push', data);
            };
          })(this)));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return FolderWatcher;

  })(events.EventEmitter);

  exports.TailWatcher = TailWatcher;

  exports.FolderWatcher = FolderWatcher;

}).call(this);
